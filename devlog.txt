Ok so the flow i am thinking is like,


From the list of products we click 'Manage variants' buttons for a product.
It will render a layout .This layout has tab at top which has [Variants] [Generate Variants]

When we click 'Variants' tab it will render 'ManageVariantsPage'
and when we click 'Generate Variants' tab it will render 'GenerateVariantsPage'


'GenerateVariantsPage'.This page lets us Generate new variants for the product. This page basically has below sections,
1.ProductDetailsCard section -> Shows the details of the product for which we are Generating the variants
2.AttributesManagement section -> shows all the attributes and for each attribute the options.
3.VariantImageManagement section -> if we have select the color attribute the this section is show. It will lets us select the images for each color. This images will be linked to the variants whos has matching color
4.VariantsTable section -> it will show the auto generated variants(different combinations based on what attributes and options are selected).
5.EditVariantDetailsForm section -> It we click the edit button of the auto generated variant item in table then this form gets open. It will show the price,sku,name of variant,Active status:true or false and images which are linked to variant color which are not editable on the variant level 


'ManageVariantsPage'. This page lets us edit the already exisiting variants in db.This page basically has sections,
1.ProductDetailsCard section -> shows the details of the product
2.VariantImageManagement section -> shows the color attributes options and we can delete or  add new images for the color.   
2.VariantsTable section -> All the Variants list in table
3.EditVariantDetailsForm section -> When we click the edit button for a variant in table then this form will get populated with the variants details. we can edit name,stock,status. This form will also show the link images which are readonly and can be edited only from VariantImageManagement section.




GenerateVariantsPage & ManageVariantsPage both are rendered in nextjs page.tsx which are server component.
ManageVariantsPage is basically the edit page which lets us edit the variants details etc..
GenerateVariantsPage is basically for creating new variants for the product.

What data ManageVariantsPage/GenerateVariantsPage will need?
1. They will require Products details
2. They will also require product's all variants(ManageVariantsPage only)
3. They will also require all the attributes and options. But for ManageVariantsPage it will also require the
   attributes and options for which the variants are generated. 




Flow, (for generating the new variants)
Admin/Store manager clicks the 'Manage Variants button for a product'.
It will render a layout which has tabs at top. Admin/Store manager will select 'Generate Variants' tab.

GenerateVariantsPage opens.
It will show products details,
All the products attributes and options.

Admin/Store manager selects the options.A attribute is considered selected if at least one options is selected.
If there is Color attribute and we admin selects any one color we also show 'VariantImageManagement' component.
'VariantImageManagement' will show the colors selected as tabs. So if the admin has selected 'Red', 'Green'
and 'Blue' color then VariantImageManagement will show this colors as tabs. If we select any color tab
it opens a image selection input which lets us select multiple image for the color. 
So for each color options we can select images. If admin unselects the any color option in AttributesManagement
then that color tab will also disappears from the VariantImageManagement color tabs.

At this point the admin has selected the attribute options and for color attribute he has selected images.

He the clicks the 'Generate variants' button. This will generate all the combinations(variants) and will be rendered in 
a table 'VariantsTable'. Each table item has edit button.  Clicking the edit button opens 'EditVariantDetailsForm'.
As we are at 'GenerateVariantsPage' this EditVariantDetailsForm will only show the sku of variant at top.
Price will be the base price of the product, stock,name,status will be default. admin will change the values.
This 'EditVariantDetailsForm' will also show the images for the variant color. This image however are readonly.

Now there is a button 'Save Variant'. When the admin clicks this button then the variant is saved(not in db but in component state only).
So admin can change the values for each variant and save them individually. 

Now at the end we have 'Save Variants' button. Clicking on this we will Save all the variants to the db. Upload images to cloudinary etc, etc stuff.




Flow(for editing the exisiting variants of a product).
Admin/Store manager clicks the 'Manage Variants button for a product'.
It will render a layout which has tabs at top. Admin/Store manager will select 'Variants' tab.

ManageVariantsPage opens.
It will show products details,
All the exisiting variants of the product in a table 'VariantsTable'.
Admin click the eidt button of a particular variant. This will open 'EditVariantDetailsForm'.
It will get populated with all the variants details. Admin can edit all the details, excepts the images. They are still
readonly. If admin want to change the image he can do it from the 'VariantImageManagement'.
'VariantImageManagement' will show the Color options which are associated with the exisiting variants.
Admin can edit image for each color.
Similar to the 'GenerateVariantsPage' each variant will be edited and saved to component state.

At last when the admin clicks the 'Save Variants' then we make changes to db.



Key difference b/w 'GenerateVariantsPage' and 'ManageVariantsPage'.

In 'GenerateVariantsPage' we can toggle the attribute options.
In 'ManageVariantsPage' attributes and their options are just readable and all the associated options will be pre-selected. We can toggle them.

In 'GenerateVariantsPage',  VariantImageManagement will show the color options which admin has toggle in 'AttributesManagement'.
In 'ManageVariantsPage', we will show the color options associated with all the exisiting variants.

Special case.
If a product has exisiting variants and admin decides to Generate new variants.
The flow will be same for GenerateVariantsPage, but once we generate we will check if the variants allready exists
in the  exisiting variants, then we higlight the variants which are duplicate in VariantsTable. Until the user removes the
duplicate ones we wont let the 'Save Variants' button to work.


Now go throught the above everything and tell me you understand it or not. Explain me in very short and crisp what u understand.







lets start with GenerateVariantsPage logic.
We have productId,
We will need, 
product details for productId,
exisitingVariants,
all attributes with options,

/api/admin/products/[productId]variants-data



i have implemented the toggle function

  const [attributes, setAttributes] = useState<Attribute[]>([]);

    const toggleAttributeOption = (attributeId: number, optionId: number) => {
        setAttributes((prevAttributes) =>
        prevAttributes.map((attribute) => {
            if (attribute.id === attributeId) {
            return {
                ...attribute,
                options: attribute.options.map((option) =>
                option.id === optionId
                    ? { ...option, selected: !option.selected }
                    : option
                ),
            };
            }
            return attribute;
        })
        );
    };


Now i want that if color options is selected that that color options will be shown as tabs and for each tab we can select the images. Now since i am left with only question that i can ask to you, i want that in that on response you gave me all the logic i need.


So as of now we can toggle the attribute options.
I want that if the color options are selected then we want to show them as tabs. This tabs lets us
select images for each color. 
So i want to render the selected color options as tabs. 
So we need a useState to add the color options.

Also we need to upload the image which are linked to color option(optionId,attributeId,productId).
So when we select a color options from the tab we show its images we can delete the images add new one 
Now we need to maintain the actual  File data and image preview url also so that images can be preview.

now i have a div which has plus icon. I have a hidden input which lets admin select mulitple image for that color.
There is a container which will show the preview of the selected images. Each image has remove buttons
which will let us remove that image. We can do this for all color option.

We will also have a fileInputRef. When we click on div the input will be fire to take images input.
When we select the images they will be map to that color. 
Also when we generate the variants we want to show the images for that variant's  color.

Now lets not focus on ui, but focus on image selection, removing, options color tabs,
image preivews. You can take assume some dummy ui in your response. 





OK so,
in ManageVariantsPage we render the db existing variants in VariantsTable
in GenerateVariantsPage we render the variants from the generatedVariants state in VariantsTable


In VariantsTable if we click edit button we populates the 'EditVariantDetailsForm' with the details
of the clicked variants. we make changes to the variants details and then we hit save variant.
Hitting the save variant calls the function 'updateVariant' in context and which update update the
state. Now in case of GenerateVariantsPage it updates the generatedVariants state's data like below and we see the changes in table's variant data.
const updateVariant = (updatedVariant: GeneratedVariant) => {
    setGeneratedVariants((prevVariants) =>
      prevVariants.map((variant) =>
        variant.sku === updatedVariant.sku ? updatedVariant : variant
      )
    );
  };

But now in case of ManageVariantsPage this function will call the same updateVariant and it will update generatedVariant's data
but we are rendering the variant data from the db that are stored in variants useState and due to this we dont see any updates in table items.
  const [variants, setVariants] = useState<Variant[]>([]);









/-------------------

both ManageVariantsPage and GenerateVariantsPage shows 'AttributesManagement'.
AttributesManagement shows all the attributes and options. If the arritbute and options is associated with
the exisiting variants we pre selected them and they show green color.

GenerateVariantsPage shows all the attributes and options for the product category and pre selects the associated ones.
ManageVariantsPage shows only the associated attributes and options with green color. We dont show all attributes

for 'GenerateVariantsPage' we let admin toggle the options. 
for 'ManageVariantsPage' we wont let toggle options because we are showing only the associated attributes and options for exisiting variants.






<AttributesManagement attributes={attributesData} />

import React, { useEffect } from "react";
// import { productAttributes as attributes } from "@/utils/sampleData";
import { Icon } from "@iconify/react/dist/iconify.js";
import { Attribute } from "@/types/variantsNewTypes";
import { useVariantManagementContext } from "@/context/VariantManagementContext";

interface AttributesManagementProps {
  attributes: Attribute[];
}
const AttributesManagement: React.FC<AttributesManagementProps> = ({
  attributes,
}) => {
  const {
    setAttributes,
    attributes: attributesData,
    toggleAttributeOption,
  } = useVariantManagementContext();

  useEffect(() => {
    setAttributes(attributes);
  }, [attributes, setAttributes]);

  return (
    <>
      <div className="w-full h-[40px] flex items-center bg-[#e4f0ff] px-[10px] border-b border-[#D0D5DD]">
        <p className="text-[0.8rem] font-medium ">SELECT ATTRIBUTE & OPTIONS</p>
      </div>
      <div className="w-full h-[calc(100%-40px)] border-red-500 p-[8px]">
        <div className="w-full h-[40px] flex items-center justify-start mb-[10px]">
          <p className="text-[0.8rem] font-normal text-[#A4ADBB]">
            An attribute is considered selected when at least one of its options
            is chosen.
          </p>
        </div>

        {attributesData && (
          <div className="w-[100%] h-auto flex flex-col border border-[#D0D5DD] p-[10px] rounded">
            {attributesData.map((attr) => (
              <div className="w-full h-auto flex flex-col" key={attr.id}>
                <div className="w-full h-[30px] flex items-center">
                  <div className="w-auto h-[80%] flex items-center justify-center text-[0.75rem] font-medium">
                    {attr.name.toUpperCase()}
                  </div>
                </div>
                <div className="w-full h-auto min-h-[40px] flex flex-wrap">
                  {Object.values(attr.options).map((attrOption) => (
                    // checkbox
                    <div
                      onClick={() =>
                        toggleAttributeOption(attr.id, attrOption.id)
                      }
                      key={attrOption.id}
                      className={`w-auto h-[30px] flex my-[10px] mr-[10px] rounded-full border border-[#D0D5DD]  ${
                        attrOption.selected
                          ? "bg-[#e4f0ff]"
                          : "bg-[transparent]"
                      } text-[0.7rem] font-medium cursor-pointer`}
                    >
                      <div className="h-full aspect-square rounded-full flex items-center justify-center  bg-white">
                        <Icon
                          icon="flowbite:check-outline"
                          className={`w-[50%] h-[50%]  ${
                            attrOption.selected
                              ? "text-[#039855]"
                              : "text-[#A4ADBB]"
                          }`}
                        />
                      </div>
                      <div
                        className={`h-full flex-1 flex items-center justify-center pl-[5px] pr-[10px]  ${
                          attrOption.selected
                            ? "text-[#039855]"
                            : "text-[#A4ADBB]"
                        }`}
                      >
                        {attrOption.value}
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            ))}
          </div>
        )}
      </div>
    </>
  );
};

export default AttributesManagement;






lets fix the EditVariantDetailsForm, showing the images.

images are tied to the colors.


interface ColorImageData {
  optionId: number;
  attributeId: number;
  productId: number;
  files: File[];
  previews: string[];
}
  const [colorImages, setColorImages] = useState<{
    [optionId: number]: ColorImageData;
  }>({});

CASE 1:
For GenerateVariantsPage we click edit button on table's variant it opens,
EditVariantDetailsForm and shows the generate variants details which can chnaged.
Form also shows the images linked to that variant's color. These images are readonly.
These images are coming from the 'colorImages' state. If we add or remove the images for specific color from
the 'VariantImageManagement' it also reflects in the form. From the form we can change but from 'VariantImageManagement' 
we can change. So images are can be add and removed for color level not variant level. Everything works fine in this case. 

CASE 2:
For ManageVariantsPage we click edit button on table's variant it opens,
EditVariantDetailsForm and shows the variant's details which can chnaged.
Form should shows the images linked to that variant's color. These images are readonly.
Now the images for 'GenerateVariantsPage' was comming from the 'colorImages' state. But for ManageVariantsPage case
we have images in variants data coming from the db. these images are urls of cloudinary.


Now if use colorImages for both ManageVariantsPage and GenerateVariantsPage as a centralized data to show images,
we need to handle some cases.


In case of GenerateVariantsPage we when finally created the variants in db, before which we upload images to
cloudinary, the payload had 'newImage' array,

const images =
        colorAttr && colorImages[colorAttr.optionId]
          ? colorImages[colorAttr.optionId].files.map((file, index) => ({
              file,
              order: index,
            }))
          : [];

 payload={
 //other data,  .... 
 newImages: images
 }         


This was the final images that needs to be upload in cloudinary and metadata to db.



Now for both GenerateVariantsPage and ManageVariantsPage, we shows the 'VariantImageManagement'.
This component lets us upload images for each color. 
It also shows the images preview from colorImages 'previews' array.

Now in case of ManageVariantsPage,  VariantImageManagement needs to show exisiting images for the variants
coming from the db. It should let us upload new images and if we remove the image which was already in db data then we
need to also delete that data from the cloudinary also. 


So what we can do is we can updata the colorImages state to maintain all the data for 
preview of new images or exisiting images. also track if images are removed from the exisiting db images and etc.


In case of GenerateVariantsPage, colorImages will have not data at first. It will get update when we selects the images for the
color. But in case of ManageVariantsPage we need to initialize the colorImages state because we already have exisiting variants
and we have images for them.


So the VariantImageManagement will render the previews from the single source of truth i.e colorImages
FOr a editing variant it will also show the preivew of image form the colorImages.




So now update context, VariantImageManagement, etc..


import {
  Attribute,
  GeneratedVariant,
  ProductDetails,
  Variant,
  VariantAttribute,
} from "@/types/variantsNewTypes";
import {
  createContext,
  useContext,
  useState,
  ReactNode,
  useEffect,
} from "react";

interface ColorImageData {
  optionId: number;
  attributeId: number;
  productId: number;
  files: File[];
  previews: string[];
}

interface VariantManagementContextType {
  product: ProductDetails | null;
  attributes: Attribute[];
  variants: Variant[];
  setProduct: (product: ProductDetails | null) => void;
  setAttributes: (attributes: Attribute[]) => void;
  setVariants: (variants: Variant[]) => void;
  setActiveColorTab: (activeColorTab: number | null) => void;
  setEditingVariant: (editingVariant: GeneratedVariant | null) => void;
  editingVariant: GeneratedVariant | null;
  generatedVariants: GeneratedVariant[];
  activeColorTab: number | null;
  hasDuplicates: boolean;
  colorImages: { [optionId: number]: ColorImageData };
  updateVariant: (updatedVariant: GeneratedVariant) => void;
  isDuplicate: (variant: GeneratedVariant) => boolean;

  toggleAttributeOption: (attributeId: number, optionId: number) => void;
  addColorImages: (
    optionId: number,
    attributeId: number,
    productId: number,
    files: File[]
  ) => void;

  removeColorImage: (optionId: number, index: number) => void;
  generateVariants: () => void;

  removeGeneratedVariant: (sku: string) => void;
}

const VariantManagementContext = createContext<
  VariantManagementContextType | undefined
>(undefined);

export const VariantManagementProvider = ({
  children,
}: {
  children: ReactNode;
}) => {
  //-- USE STATES ------------------------------------------------------------------------------------------------------------------------------
  const [product, setProduct] = useState<ProductDetails | null>(null);
  const [attributes, setAttributes] = useState<Attribute[]>([]);
  const [variants, setVariants] = useState<Variant[]>([]);
  const [activeColorTab, setActiveColorTab] = useState<number | null>(null);
  const [colorImages, setColorImages] = useState<{
    [optionId: number]: ColorImageData;
  }>({});
  const [generatedVariants, setGeneratedVariants] = useState<
    GeneratedVariant[]
  >([]);

  const [editingVariant, setEditingVariant] = useState<GeneratedVariant | null>(
    null
  );
  const [hasDuplicates, setHasDuplicates] = useState<boolean>(false);

  //-- HANDLER FUNCTION ------------------------------------------------------------------------------------------------------------------------

  // Centralized duplicate checking
  const isDuplicate = (variant: GeneratedVariant) => {
    // console.log("Checking duplicate for variant:", variant);
    const newAttrSet = new Set(
      variant.attributes.map((attr) => `${attr.attributeId}:${attr.optionId}`)
    );
    // console.log("New attribute set:", [...newAttrSet]);

    return variants.some((existing) => {
      const existingAttrSet = new Set(
        existing.attributes.map(
          (attr) => `${attr.attributeId}:${attr.optionId}`
        )
      );
      // console.log("Existing variant:", existing);
      // console.log("Existing attribute set:", [...existingAttrSet]);
      const isMatch =
        newAttrSet.size === existingAttrSet.size &&
        [...newAttrSet].every((attr) => existingAttrSet.has(attr));
      // console.log("Is duplicate:", isMatch);
      return isMatch;
    });
  };

  useEffect(() => {
    const checkDuplicates = () => {
      const hasAnyDuplicates = generatedVariants.some((variant) =>
        isDuplicate(variant)
      );
      // console.log("Generated variants:", generatedVariants);
      // console.log("Existing variants:", variants);
      // console.log("hasAnyDuplicates:", hasAnyDuplicates);
      setHasDuplicates(hasAnyDuplicates);
    };
    checkDuplicates();
  }, [generatedVariants, variants]);

  const toggleAttributeOption = (attributeId: number, optionId: number) => {
    setAttributes((prevAttributes) =>
      prevAttributes.map((attribute) => {
        if (attribute.id === attributeId) {
          return {
            ...attribute,
            options: attribute.options.map((option) =>
              option.id === optionId
                ? { ...option, selected: !option.selected }
                : option
            ),
          };
        }
        return attribute;
      })
    );
  };

  const addColorImages = (
    optionId: number,
    attributeId: number,
    productId: number,
    files: File[]
  ) => {
    setColorImages((prev) => {
      const existing = prev[optionId] || {
        optionId,
        attributeId,
        productId,
        files: [],
        previews: [],
      };
      const newFiles = [...existing.files, ...files];
      const newPreviews = [
        ...existing.previews,
        ...files.map((file) => URL.createObjectURL(file)),
      ];
      return {
        ...prev,
        [optionId]: {
          ...existing,
          files: newFiles,
          previews: newPreviews,
        },
      };
    });
  };

  const removeColorImage = (optionId: number, index: number) => {
    setColorImages((prev) => {
      const existing = prev[optionId];
      if (!existing) return prev;

      URL.revokeObjectURL(existing.previews[index]);

      const newFiles = existing.files.filter((_, i) => i !== index);
      const newPreviews = existing.previews.filter((_, i) => i !== index);
      return {
        ...prev,
        [optionId]: {
          ...existing,
          files: newFiles,
          previews: newPreviews,
        },
      };
    });
  };

  const generateVariants = () => {
    if (!product) return;

    // Filter attributes with selected options
    const selectedAttributes = attributes.filter((attr) =>
      attr.options.some((opt) => opt.selected)
    );
    if (selectedAttributes.length === 0) return;

    // Generate all combinations
    const combinations = selectedAttributes.reduce((acc, attr) => {
      const selectedOptions = attr.options.filter((opt) => opt.selected);
      const newCombinations: VariantAttribute[][] = [];
      selectedOptions.forEach((opt) => {
        const attrCombo = {
          attributeId: attr.id,
          attributeName: attr.name,
          optionId: opt.id,
          optionValue: opt.value,
        };
        if (acc.length === 0) {
          newCombinations.push([attrCombo]);
        } else {
          acc.forEach((combo) => {
            newCombinations.push([...combo, attrCombo]);
          });
        }
      });
      return newCombinations;
    }, [] as VariantAttribute[][]);

    // Create descriptive SKUs and variants
    const newVariants: GeneratedVariant[] = combinations.map((combo) => {
      // Generate SKU: ProductName-OptionValue1-OptionValue2-...
      const skuParts = [
        product.name.replace(/\s+/g, "-"),
        ...combo.map((attr) => attr.optionValue.replace(/\s+/g, "-")),
      ];
      const sku = skuParts.join("-").toLowerCase();

      return {
        sku,
        name: product.name,
        slug: "",
        price: product.basePrice,
        stock: 0,
        status: "ACTIVE",
        attributes: combo,
      };
    });

    setGeneratedVariants(newVariants);
  };

  const updateVariant = (updatedVariant: Variant | GeneratedVariant) => {
    if ("id" in updatedVariant) {
      // Update variants state for ManageVariantsPage
      setVariants((prevVariants) =>
        prevVariants.map((variant) =>
          variant.id === updatedVariant.id
            ? { ...variant, ...updatedVariant }
            : variant
        )
      );
    } else {
      // Update generatedVariants state for GenerateVariantsPage
      setGeneratedVariants((prevVariants) =>
        prevVariants.map((variant) =>
          variant.sku === updatedVariant.sku ? updatedVariant : variant
        )
      );
    }
  };

  const removeGeneratedVariant = (sku: string) => {
    setGeneratedVariants((prevVariants) =>
      prevVariants.filter((variant) => variant.sku !== sku)
    );
  };

  const value: VariantManagementContextType = {
    product,
    attributes,
    variants,
    setProduct,
    setAttributes,
    setVariants,
    toggleAttributeOption,
    colorImages,
    addColorImages,
    removeColorImage,
    setActiveColorTab,
    activeColorTab,
    generatedVariants,
    generateVariants,
    editingVariant,
    setEditingVariant,
    updateVariant,
    removeGeneratedVariant,
    isDuplicate,
    hasDuplicates,
  };

  return (
    <VariantManagementContext.Provider value={value}>
      {children}
    </VariantManagementContext.Provider>
  );
};

export const useVariantManagementContext = () => {
  const context = useContext(VariantManagementContext);
  if (!context) {
    throw new Error(
      "useVariantManagementContext must be used within a VariantManagementProvider"
    );
  }
  return context;
};


import { useVariantManagementContext } from "@/context/VariantManagementContext";
import Image from "next/image";
import React from "react";

const EditVariantDetailsForm = () => {
  const { editingVariant, setEditingVariant, colorImages, updateVariant } =
    useVariantManagementContext();

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (!editingVariant) return;

    const { name, value, type } = e.target;
    setEditingVariant({
      ...editingVariant,
      [name]: type === "number" ? Number(value) : value,
    });
  };

  const handleSaveVariant = () => {
    if (editingVariant) {
      updateVariant(editingVariant);
      // Optional: Close the form or show success message
      setEditingVariant(null);
    }
  };

  if (!editingVariant) return null;

  const isVariant = "id" in editingVariant;
  const variantColorOptionId = editingVariant.attributes.find(
    (attr) => attr.attributeName.toLowerCase() === "color"
  )?.optionId;
  const variantImages = isVariant
    ? editingVariant.images
    : variantColorOptionId
    ? colorImages[variantColorOptionId]?.previews || []
    : [];

  return (
    <>
      <div className="w-full h-[40px] flex items-center bg-[#e4f0ff] px-[10px] rounded-t border border-[#D0D5DD]">
        <p className="text-[0.8rem] font-medium"># {editingVariant?.sku}</p>
      </div>
      <div className="w-full h-[calc(100%-40px)] border-x border-b border-[#D0D5DD] p-[10px] overflow-y-scroll hide-scrollbar">
        <section className="w-full h-[auto] flex flex-col border border-[#D0D5DD] p-[10px] rounded">
          <div className="w-[100%] h-[100px] flex flex-col border-blue-700">
            <div className="w-full h-[30px] flex items-center justify-start">
              <label htmlFor="name" className="text-[0.8rem] font-medium">
                VARIANT NAME
              </label>
            </div>
            <div className="w-full h-[40px] flex items-center justify-start">
              <input
                name="name"
                value={editingVariant.name}
                onChange={handleInputChange}
                className={`w-full h-full text-[0.8rem] placeholder:text-[0.75rem] border-b border-[#D0D5DD]`}
              />
            </div>
            <div className="w-full h-[30px] flex items-center justify-start"></div>
          </div>
          <div className="w-[100%] h-[100px] flex flex-col border-blue-700">
            <div className="w-full h-[30px] flex items-center justify-start">
              <label htmlFor="name" className="text-[0.8rem] font-medium">
                PRICE (â‚¹)
              </label>
            </div>
            <div className="w-full h-[40px] flex items-center justify-start">
              <input
                type="number"
                step="0.10"
                name="price"
                value={editingVariant.price}
                onChange={handleInputChange}
                min={1}
                className={`w-full h-full text-[0.8rem] placeholder:text-[0.75rem] border-b border-[#D0D5DD]`}
              />
            </div>
            <div className="w-full h-[30px] flex items-center justify-start"></div>
          </div>
          <div className="w-[100%] h-[100px] flex flex-col border-blue-700">
            <div className="w-full h-[30px] flex items-center justify-start">
              <label htmlFor="name" className="text-[0.8rem] font-medium">
                STOCK
              </label>
            </div>
            <div className="w-full h-[40px] flex items-center justify-start">
              <input
                type="number"
                step="1"
                min={0}
                name="stock"
                value={editingVariant.stock}
                onChange={handleInputChange}
                className={`w-full h-full text-[0.8rem] placeholder:text-[0.75rem] border-b border-[#D0D5DD]`}
              />
            </div>
            <div className="w-full h-[30px] flex items-center justify-start"></div>
          </div>

          <div className="w-[100%] h-[auto] flex flex-col border-blue-700">
            <div className="w-full h-[30px] flex items-center justify-start">
              <label className="text-[0.8rem] font-medium">STATUS</label>
            </div>
            <div className="w-full h-[auto] grid grid-cols-[50%_50%] grid-rows-[40px_40px] gap-[5px] p-[2px]">
              <button
                className={`w-[80%] h-[95%] flex  rounded-full border border-[#039855]  ${
                  true ? "bg-[#e4f0ff]" : "bg-[transparent]"
                } text-[0.7rem] font-medium cursor-pointer`}
              >
                <div className="h-full aspect-square rounded-full flex items-center justify-center bg-white">
                  <div className="w-[5px] aspect-square rounded-full bg-[#039855]"></div>
                </div>
                <div
                  className={`h-full flex-1 flex items-center justify-center pl-[5px] pr-[10px]  ${
                    true ? "text-[#039855]" : "text-[#A4ADBB]"
                  }`}
                >
                  ACTIVE
                </div>
              </button>
              <button
                className={`w-[80%] h-[95%] flex  rounded-full border border-[#F04438]  ${
                  true ? "bg-[#e4f0ff]" : "bg-[transparent]"
                } text-[0.7rem] font-medium cursor-pointer`}
              >
                <div className="h-full aspect-square rounded-full flex items-center justify-center  bg-white">
                  <div className="w-[5px] aspect-square rounded-full bg-[#F04438]"></div>
                </div>
                <div
                  className={`h-full flex-1 flex items-center justify-center pl-[5px] pr-[10px]  ${
                    true ? "text-[#F04438]" : "text-[#A4ADBB]"
                  }`}
                >
                  INACTIVE
                </div>
              </button>
              <button
                className={`w-[80%] h-[95%] flex  rounded-full border border-[#F04438]  ${
                  true ? "bg-[#e4f0ff]" : "bg-[transparent]"
                } text-[0.7rem] font-medium cursor-pointer`}
              >
                <div className="h-full aspect-square rounded-full flex items-center justify-center  bg-white">
                  <div className="w-[5px] aspect-square rounded-full bg-[#F04438]"></div>
                </div>
                <div
                  className={`h-full flex-1 flex items-center justify-center pl-[5px] pr-[10px] text-[0.4rem]  ${
                    true ? "text-[#F04438]" : "text-[#A4ADBB]"
                  }`}
                >
                  OUT OF STOCK
                </div>
              </button>
            </div>
            <div className="w-full h-[30px] flex items-center justify-start"></div>
          </div>
        </section>
        <section className="w-full h-auto border border-[#D0D5DD] mt-[10px] p-[5px]">
          <div className="w-full h-[30px] flex items-center border-b border-[#D0D5DD]">
            <p className="text-[0.7rem] font-medium">
              VARIANT IMAGES - READ ONLY
            </p>
          </div>
          <div className="w-full h-auto max-h-[300px] overflow-y-scroll hide-scrollbar grid grid-cols-2 gap-5 mt-[10px]">
            {variantImages.length > 0 ? (
              variantImages.map((image, index) => (
                <div
                  key={index}
                  className="relative w-[100%] aspect-square border border-[#D0D5DD] rounded"
                >
                  <Image
                    src={isVariant ? image.url : image}
                    alt={`Image ${index}`}
                    fill
                    className="object-cover"
                    sizes="(max-width: 768px) 100px, 100px"
                  />
                </div>
              ))
            ) : (
              <p className="text-[0.7rem] text-gray-500">No images available</p>
            )}
          </div>
        </section>
      </div>
      <div className="w-full h-[50px] flex items-center justify-end px-[5px] border-x border-b border-[#D0D5DD]">
        <button
          onClick={handleSaveVariant}
          className="w-auto h-auto px-[10px] py-[8px] disabled:bg-gray-400 bg-[#635DB0] text-white text-[0.7rem] cursor-pointer"
        >
          Save variant
        </button>
      </div>
    </>
  );
};

export default EditVariantDetailsForm;


















I identified one problem.


let say we have color options
'White titanium'
'Black titanium'

Storage options,
128GB
512GB


At first for a prdocut we did not had any variants so we went on generating new ones.

Admin selects 128GB and 'White titanium' and selectes the images and we creat a variants
for 128GB-'White titanium' in db.


Now next time for the same product admin decides to generate more variants. so
it went on managing the products variant. Now we have 128GB-'White titanium' variant.

Admin on GenerateVariantsPage wants to create a variant for 512-'White titanium'.

but now the problem is that we are not generating variant for pre-selected options and also the 
AttributesManagement component has disabled the 'White titanium' color because its readonly now.

So now even if 'White titanium' option is associated with the exisiting variant in db
but admin should be able to generate 512-white-titanium variant.

So now how to mitigate this issue. 
We should allow admin to generate new variants but not allow to edit the exisiting from GenerateVariantsPage.



this creates infinite re-rendering and max depth reached issue.
if we remove 'initializeColorImages' from dependency array then the issue is gone but 
eslint say
React Hook useEffect has a missing dependency: 'initializeColorImages'. Either include it or remove the dependency array.eslintreact-hooks/exhaustive-deps
const setVariants: (variants: Variant[]) => void

  useEffect(() => {
    setProduct(productData);
    setAttributes(attributesData);
    setVariants(variants);
    initializeColorImages(variants); // Initialize colorImages with existing variant images
  }, [productData, attributesData, variants, setProduct, setAttributes, setVariants, initializeColorImages]);





Now everything seems fine. So now lets work on the variants update logic in
db and edit images in cloudinary.


so if we made changes to multiple variants data like their stock,name,status(as of now ACTIVE is default. we are not toggling/changing it from ui so ignore),
added new images, remove exisiting ones for the variant associated colorOptions
then we need to update all that info in  db and cloudinary.

We have 'Save Variant' button in EditVariantDetailsForm for individual variant
and when we click on it it updates the state only and not the data in db.
The actual updation happens when we click 'Update Variants' button.


  const handleUpdateVariants = async () => {
    setError(null);
    setIsLoading(true);
    try {
    } catch (err) {
      setError(
        err instanceof Error ? err.message : "Failed to update variants"
      );
    } finally {
      setIsLoading(false);
    }
  };


 <button
                onClick={handleUpdateVariants}
                disabled={isLoading}
                className="w-auto h-auto px-[10px] py-[8px] disabled:bg-gray-400 bg-[#635DB0] text-white text-[0.7rem] cursor-pointer"
              >
                {isLoading ? "Updating..." : "Update Variants"}
              </button>





Now things are messed up more.


Case1: No images exists.
admin uploads 3 images.
Images are added to cloudinary and images are inserted in table.  
Works fine.

Case2: Deletes all images for the colorOption
Three images exist.
Admin deletes all the images.
cloudinary all images are deleted. table all images are deleted for the color option.
Works fine.


Case3: Delete 2 out of 3 three images for a color option.
Three images exists
Admin deletes two images from three.
Two images does get deleted from cloudinary.
Two images are gets removed from the table.
The remaining one image insert again and now we have two same images.




so lets re-write the logic again.

so one thing for sure we will do is for a variant we will 
remove all the exisiting images.

Now in our payload we have 'images' array.
This is the final images array that needs to be in db.
We also have deletedPublicIds which will be used by cloudinary to
delete our removed images.
We need to focus on 'images'.

Now carefull looking at the 'images' arr we see that
if it has three items then is concludes that we have three images
for the variants color option.

Now this 'images' array has below structure,

for exisiting images file  key is undefined,
for newly selected image file is 'File'(file data).

so what we can do is that if images array has file then i need to be 
uploaded to cloudinary. then get the meta 
and images array that object gets replaced with the cloudinary metadata.

so now the final 'images' array will have all the cloudinary images.

on backend we just need to remove all images for the 
variant and put this new array of that variant.

What you say?



images": [
      {
        "file": undefined,
        "order": 0,
        "publicId": "nexop/products/gcdwoexugsb2d3r4e8tr",
        "url": "https://res.cloudinary.com/dd4yykxrb/image/upload/v1745328951/nexop/products/gcdwoexugsb2d3r4e8tr.jpg"
      },
      {
        "file": undefined,
        "order": 1,
        "publicId": "nexop/products/pppjruzacxaqatbd2q52",
        "url": "https://res.cloudinary.com/dd4yykxrb/image/upload/v1745328955/nexop/products/pppjruzacxaqatbd2q52.jpg"
      },
      {
        "file": {
          "lastModified": 1745010818417,
          "lastModifiedDate": "Sat Apr 19 2025 02:43:38 GMT+0530 (India Standard Time)",
          "name": "images (3).jpeg",
          "size": 7459,
          "type": "image/jpeg",
          "webkitRelativePath": ""
        },
        "order": 2,
        "publicId": "temp-2",
        "url": "blob:http://localhost:3000/7e48788a-5586-44b2-9c86-8394a2a6aafe"
      }
    ],





everything worked fine. DB entries are correct now.
just that deleting a image does not works with cloudinary. Cloudinary does
not delete the image using the publicId.



on close inspection, i saw that the publicId's for the cloudinary images
in payload is like 'iphone-16-pro-128gb-white-titanium-6.3-inches-0-174533179098'
but the correct ones are like 'nexop/products/gcdwoexugsb2d3r4e8tr'.

In older versions of payload it was correct but not in the new one.







ok so everything worked fine. 
Just a minor ui problem.

so now all of the data lies on useState.

Now lets say we deleted two images from 5 and now deletedPublicIds has two images publicId.
we then hit update button and evereything gets updated. Till this point all is ok.

But now let say we again hit the update button and now as the state has same data it still has that two
publicIds.

If we referesh the page manually then there is no problem. but if without refreshing we do some operation then we have problem.
So Either we refresh the page manually or we need some kind of logic to revalidate everything or some kind of reset.






so now there is a catch

for a give categorySlug if try to fetch the product for it,
then there are two cases.

1. Category has direct products
2. Category does not directly has products but some of its children categories has products.


for example,
'Electronics' is category and 'Smartphone' is children category.
Electronics may or may not have direct products but Smartphone has direct products.

So now when fetching the product for a category we want to consider the above two cases.

I have a menu from which i can select category or subcategory.
it takes to path /products/[categorySlug]
we then fetch the products using categorySlug.
If we have direct products then we return direct products.
if we dont then we return all of its children categories products(So this will be mixture of products)
Also the /product/[categorySlug] page along with the products it will also show
a sidebar. This sidebar will show all the attribute and option for that category.
This sidebar attribute and options will be used in later stage for filteration(as of now just ignore the implemention of filteration)
now if a category does not have direct products that means we also dont have attributes and options
so what we will do is that in sidebar we will show the catrogory's children category.

so we need to update the controller for both the cases.



OK so now we have a product detail page.
This page will open when we click product card from productList.
url will have /shop/products/[categorySloug]/[productSlug] -> renders product details page
When product details page opens we first fetch products details from products table.
so product details page will render products,name,price,brand,category,images,attributes and options.
So now when we select the attribute's options(for each attribute we can select one option at time)
we set the url with the attribute and options. so now we have searchparams in url.
Now same product detail page will render again but this time we also have searchparams that will be
set to the backend along with the productSlug. 
so now let say we select 'white titanium' color and 128gb and ram '8gb' etc..
this will all get added to url like ?color=1&storage=12&ram=6
so now we want to fetch the product's detail for the productSlug but also
consider the variants for this attribute options. so we will fetch the name of
that variant, price, image etc.  













let's re-think the logic.
leave options and attribute and sllug evereything aside for now.

according to you if we want the variant for the product
what is the most accurate way to filter it like on what basis it can be
dont with most accuracy.
I dont want any code and keep your responses crisp and clear and short


generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Category {
  id         Int         @id @default(autoincrement())
  name       String
  slug       String      @unique
  parent     Category?   @relation("CategoryToCategory", fields: [parentId], references: [id])
  parentId   Int?
  children   Category[]  @relation("CategoryToCategory")
  products   Product[]
  attributes Attribute[]
  createdAt  DateTime    @default(now())
  updatedAt  DateTime    @updatedAt

  @@index([parentId])
  @@index([slug])
}

model Attribute {
  id               Int                @id @default(autoincrement())
  name             String
  category         Category           @relation(fields: [categoryId], references: [id])
  categoryId       Int
  options          AttributeOption[]
  isFilterable     Boolean            @default(true)
  displayOrder     Int                @default(0)
  createdAt        DateTime           @default(now())
  updatedAt        DateTime           @updatedAt
  VariantAttribute VariantAttribute[]

  @@index([categoryId])
}

model AttributeOption {
  id               Int                @id @default(autoincrement())
  value            String
  attribute        Attribute          @relation(fields: [attributeId], references: [id])
  attributeId      Int
  createdAt        DateTime           @default(now())
  VariantAttribute VariantAttribute[]
  active           Boolean            @default(true)

  @@unique([attributeId, value])
  @@index([attributeId])
}

model Product {
  id          Int            @id @default(autoincrement())
  name        String
  slug        String?        @unique
  description String?
  brand       String
  basePrice   Float
  status      ProductStatus  @default(DRAFT)
  category    Category       @relation(fields: [categoryId], references: [id])
  categoryId  Int
  images      ProductImage[]
  variants    Variant[]
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt

  @@index([categoryId])
  @@index([status])
  @@index([slug])
}

enum ProductStatus {
  DRAFT
  PUBLISHED
}

model ProductImage {
  id          Int      @id @default(autoincrement())
  url         String
  publicId    String?
  altText     String?
  isThumbnail Boolean  @default(false)
  order       Int      @default(0)
  product     Product  @relation(fields: [productId], references: [id])
  productId   Int
  createdAt   DateTime @default(now())

  @@index([productId])
}

model Variant {
  id         Int                @id @default(autoincrement())
  name       String
  slug       String             @unique
  sku        String             @unique
  price      Float
  stock      Int                @default(0)
  status     VariantStatus      @default(ACTIVE)
  product    Product            @relation(fields: [productId], references: [id])
  productId  Int
  attributes VariantAttribute[]
  images     VariantImage[]
  createdAt  DateTime           @default(now())
  updatedAt  DateTime           @updatedAt

  @@index([productId])
  @@index([sku])
  @@index([slug])
}

enum VariantStatus {
  ACTIVE
  INACTIVE
  OUT_OF_STOCK
}

model VariantAttribute {
  variant     Variant         @relation(fields: [variantId], references: [id], onDelete: Cascade)
  variantId   Int
  attribute   Attribute       @relation(fields: [attributeId], references: [id])
  attributeId Int
  option      AttributeOption @relation(fields: [optionId], references: [id])
  optionId    Int
  createdAt   DateTime        @default(now())

  @@id([variantId, attributeId])
  @@index([variantId])
  @@index([attributeId, optionId])
  @@index([optionId])
}

model VariantImage {
  id        Int      @id @default(autoincrement())
  url       String
  publicId  String?
  order     Int      @default(0)
  variant   Variant  @relation(fields: [variantId], references: [id], onDelete: Cascade)
  variantId Int
  createdAt DateTime @default(now())

  @@index([variantId])
}




Also:

//http://localhost:3000/shop/products/smartphone/iphone-16-pro?attr_1=1&attr_2=12
//http://localhost:3000/shop/products/smartphone/iphone-16-pro

both of the above url renders the product details page.
without query params means we are showing the product,
with query params means we are select a specific variant
so query params is optional




so our product details page will render the detail of
the product from our response data.

product has name,brand,desc,price and images,catrogory..

now when the url sets the filters we we also get the
variant's data based on the filters in searchparams.

so product details page is more concerned about the products data
and images. I wont render the variants separately. It
just renders the products object's data and its images.

so now the filter matches a variant then we create the product data
with the vairants data like price,name,images
brand and desc are comman so it wont mattter.
if no filter the product object will have images and base product's(product in products table)
details. so we dont need variants separately.
also for a attribute we can select one option.
so for all the attributes we can select one option and url
will at max have all the attribute with only one option id for each.
This combination will match only one variant. so api call return data for
a set of filters will have match only one variant if any.

so update the api logic. as of now the current logic works fine
but if brings variant separately and also if no filters are provided 
we dont need any variant only the base product.




I have a existing payment flow setup in one of my old project.

In my next project i want the below flow,

1. User fills the form with address and other stuff
2. User clicks checkout button
3. Takes to payment form
4. enters payment details like card no, cvv,etcc.
5. clicks pay -> button shows spinner
6. if success redirects to confirm order page else shows the error.


old implementation was for a cab booking app.
Now i want for Eccommerce app


"use client";
import { PaymentController } from "@/components/Payments/PaymentController";
import { useToast } from "@/context/ToastContext";
import { driverRideStatus } from "@/utils/rideUtils";
import { createClient } from "@/utils/supabase/client";
import { useEffect, useRef, useState } from "react";
import { createToastInfo, getCurrentTime } from "@/utils/rider/rideStatusUtils";
import { getStepsCompleted } from "@/utils/rider/rideStatusUtils";
import { finishedRide } from "@/lib/services/rider/ride/rideServices";
import { RiderRideResponse } from "@/types/rideTypes";
import { useUrlParams } from "@/hooks/useUrlParams";

interface RideStatusProps {
  ongoingRide: RiderRideResponse | null;
}

const RideStatus: React.FC<RideStatusProps> = ({ ongoingRide }) => {
  const { setParams } = useUrlParams();
  // useEffect(() => {
  //   setParams({ driver: "26.2859,73.0527" });
  // }, []);

  const supabase = createClient();
  const { showToast } = useToast();
  const toastIdRef = useRef<string | number>("");

  const [rideStatusData, setRideStatusData] = useState(ongoingRide);
  const [stepsCompleted, setStepsCompleted] = useState(
    getStepsCompleted(ongoingRide?.status)
  );

  useEffect(() => {
    setStepsCompleted(getStepsCompleted(ongoingRide?.status));
    setRideStatusData(ongoingRide);
  }, [ongoingRide]);

  useEffect(() => {
    if (!ongoingRide?.id) return;

    setParams({
      src: `${ongoingRide.pickup_location.lat},${ongoingRide.pickup_location.lng}`,
      dest: `${ongoingRide.dropoff_location.lat},${ongoingRide.dropoff_location.lng}`,
      driver_location: `${ongoingRide.driver_details.location.lat},${ongoingRide.driver_details.location.lng}`,
    });

    const channel = supabase
      .channel(`rides_new_rider_ongoing_${ongoingRide.id}`)
      .on(
        "postgres_changes",
        {
          event: "UPDATE",
          schema: "public",
          table: "rides_new",
          filter: `id=eq.${ongoingRide.id}`,
        },
        (payload) => {
          const updatedRide = payload.new as RiderRideResponse;
          const newStatus = updatedRide.status;
          const toastInfo = createToastInfo(newStatus);

          const newCoords = `${updatedRide.driver_details.location.lat},${updatedRide.driver_details.location.lng}`;
          setParams({ driver: newCoords });

          setRideStatusData(updatedRide);
          setStepsCompleted(getStepsCompleted(updatedRide.status));

          if (toastInfo) {
            if (toastIdRef.current) {
              // Update existing toast
              showToast({
                type: "info",
                title: `${toastInfo.title} - ${getCurrentTime()}`,
                description: toastInfo.desc,
                toastId: toastIdRef.current,
                persistent: true,
                showCloseButton: true,
                style: {
                  ["--toast-icon-color" as string]: toastInfo.color,
                  borderColor: toastInfo.borderColor,
                  color: toastInfo.color,
                  background: toastInfo.background,
                },
              });
            } else {
              // Create new toast and store its ID
              const newToastId = showToast({
                type: "info",
                title: `${toastInfo.title} - ${getCurrentTime()}`,
                description: toastInfo.desc,
                persistent: true,
                showCloseButton: true,
                style: {
                  ["--toast-icon-color" as string]: toastInfo.iconColor,
                  borderColor: toastInfo.borderColor,
                  color: toastInfo.color,
                  background: toastInfo.background,
                },
              });
              toastIdRef.current = newToastId;
            }
          }

          // Clear toast when ride is completed
          if (
            newStatus === "TRIP_ENDED" ||
            newStatus === "COMPLETED" ||
            newStatus === "CANCELLED"
          ) {
            // setToastId("");
          }
        }
      )
      .subscribe();

    return () => {
      supabase.removeChannel(channel);
    };
  }, [ongoingRide?.id, supabase, showToast, setParams]);

  const handlePaymentSuccess = async () => {
    console.log("Payment succeeded!");
    await finishedRide(ongoingRide?.id);
  };

  return (
    <div
      className="w-[100%] md:w-[60%] h-[400px]
      border-red-500
      mt-[20px]"
    >
      <div className="w-full h-[40px] px-[15px] flex items-center">
        <p className="text-[0.8rem] text-[#B5E4FC]">LIVE TRACKING</p>
      </div>
      <div className="w-full flex-1 flex flex-col items-start justify-start px-[15px] py-[15px]">
        {driverRideStatus.map((rStatus, rStatusIndx) => (
          <div className="w-auto h-auto flex  border-red-600" key={rStatusIndx}>
            <div className="w-[15px] h-auto flex flex-col items-center">
              <div
                className={`w-full aspect-square flex items-center justify-center border ${stepsCompleted >= rStatusIndx + 1 ? "border-white" : "border-[#454849]"} rounded-full`}
              >
                <div
                  className={`w-[80%] aspect-square rounded-full border-2 ${stepsCompleted >= rStatusIndx + 1 ? rStatus.border : "border-[#454849]"} `}
                ></div>
              </div>
              <div
                className={`w-[1px]  flex-1 ${stepsCompleted >= rStatusIndx + 1 ? "bg-white" : "bg-[#454849]"}`}
              ></div>
            </div>
            <div className="w-auto h-auto flex flex-col pb-[20px]">
              <p
                className={`text-[1rem] font-normal ml-[20px] ${stepsCompleted >= rStatusIndx + 1 ? "text-white" : "text-[#454849]"}`}
              >
                {rStatus.label1}
              </p>
              <p
                className={`text-[0.8rem] font-light ml-[20px] ${stepsCompleted >= rStatusIndx + 1 ? "text-white" : "text-[#454849]"}`}
              >
                {rStatus.label2}
              </p>
            </div>
          </div>
        ))}
      </div>

      <div className="w-[100%] h-auto flex items-center justify-start border-green-500 md:p-[5px]">
        {rideStatusData?.status === "TRIP_ENDED" && (
          <PaymentController
            amount={rideStatusData.fare}
            onPaymentSuccess={handlePaymentSuccess}
          />
        )}
      </div>
    </div>
  );
};

export default RideStatus;


import { useRouter } from "next/navigation";
import { useRef, useState } from "react";
import { Elements } from "@stripe/react-stripe-js";
import { StripePaymentForm } from "./StripePaymentForm";
import { loadStripe } from "@stripe/stripe-js";
import { paymentInitiate } from "@/lib/services/payment/paymentServices";
import LoadingSpinner from "../Common/Spinner/LoadingSpinner";
import { useToast } from "@/context/ToastContext"; // Import your toast context

const stripePromise = loadStripe(
  process.env.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY!
);

interface PaymentControllerProps {
  amount: number;
  onPaymentSuccess: () => void;
}

export const PaymentController = ({
  amount,
  onPaymentSuccess,
}: PaymentControllerProps) => {
  const router = useRouter();
  const { showToast, dismissToast } = useToast(); // Get toast function
  const [showForm, setShowForm] = useState(false);
  const [clientSecret, setClientSecret] = useState("");
  const [initiatingForm, setInitiatingForm] = useState(false);
  const [isProcessing, setIsProcessing] = useState(false);
  const toastIdRef = useRef<string | number>("");

  const handlePaymentInitiated = async () => {
    setInitiatingForm(true);
    try {
      const response = await paymentInitiate(amount);
      const { clientSecret } = response;
      setClientSecret(clientSecret);
      setShowForm(true);
    } catch (error) {
      console.error("Error creating payment intent:", error);
    } finally {
      setInitiatingForm(false);
    }
  };

  const handlePaymentSuccess = async () => {
    setShowForm(false);
    setIsProcessing(true);

    // Show success toast
    const toastId = showToast({
      type: "loading",
      title: "Payment Successful",
      description: "Redirecting to your trip...",
      persistent: false,
      duration: 3000,
      showCloseButton: true,
      style: {
        background: "#ECFDF5",
        color: "#065F46",
        borderColor: "#A7F3D0",
        iconColor: "#A7F3D0",
      },
    });

    toastIdRef.current = toastId;

    try {
      // 1.Call finish ride which make api request to backend to complete the payment
      onPaymentSuccess();

      // 2. Wait for 3 secs
      await new Promise((resolve) => setTimeout(resolve, 3000));

      // 3. dismiss the toast
      dismissToast(toastIdRef.current);

      // 4. redirect
      router.push("/user/trip/book-ride");
    } catch (error) {
      console.error("Error completing ride:", error);
      showToast({
        type: "error",
        title: "Error",
        description: "Could not complete ride",
      });
    } finally {
      setIsProcessing(false);
    }
  };

  const handleCancel = () => {
    setShowForm(false);
    setClientSecret("");
  };

  return (
    <div className="w-[100%] h-auto flex border-red-500 md:p-[5px]">
      {!showForm ? (
        <button
          onClick={handlePaymentInitiated}
          disabled={isProcessing}
          className={`
           w-full h-[40px] flex items-center justify-center bg-[#B5E4FC] cursor-pointer
           border border-[#3C3C3C]
           rounded
           hover:bg-[#E0F2FE] hover:ring-1
           transition-colors duration-200
           ${isProcessing ? "opacity-50 cursor-not-allowed" : ""}
       `}
        >
          {initiatingForm || isProcessing ? (
            <LoadingSpinner />
          ) : (
            <p className="font-medium text-[0.9rem] text-black">
              Make Payment INR - â‚¹{amount}
            </p>
          )}
        </button>
      ) : clientSecret ? (
        <Elements
          stripe={stripePromise}
          options={{
            clientSecret,
            appearance: {
              theme: "stripe",
              variables: {
                borderRadius: "5px 5px 5px 5px",
                colorPrimary: "#B5E4FC",
                colorBackground: "#202325",
                colorText: "#ffffff",
                colorDanger: "#df1b41",
                fontFamily: "Lufga, system-ui, sans-serif",
              },
              rules: {
                ".Label": {
                  fontSize: "0.7rem",
                },
                ".Input": {
                  fontSize: "0.8rem",
                },
              },
            },
          }}
        >
          <StripePaymentForm
            clientSecret={clientSecret}
            amount={amount}
            onPaymentSuccess={handlePaymentSuccess}
            onCancel={handleCancel}
          />
        </Elements>
      ) : (
        <div className="flex justify-center py-4">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-gray-900"></div>
        </div>
      )}
    </div>
  );
};


"use client";

import {
  PaymentElement,
  useStripe,
  useElements,
} from "@stripe/react-stripe-js";
import { useState } from "react";
import { Oval } from "react-loader-spinner";

interface StripePaymentFormProps {
  clientSecret: string;
  amount: number;
  onPaymentSuccess: () => void;
  onCancel: () => void;
}

export const StripePaymentForm = ({
  //   clientSecret,
  amount,
  onPaymentSuccess,
  onCancel,
}: StripePaymentFormProps) => {
  const stripe = useStripe();
  const elements = useElements();
  const [message, setMessage] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!stripe || !elements) return;

    setIsLoading(true);
    setMessage(null);

    const { error } = await stripe.confirmPayment({
      elements,
      confirmParams: {
        return_url: `${window.location.origin}/payment/success`,
      },
      redirect: "if_required",
    });

    if (error) {
      setMessage(error.message || "An unexpected error occurred");
    } else {
      onPaymentSuccess();
    }

    setIsLoading(false);
  };

  return (
    <div className="w-[100%] h-auto md:p-[10px] border-blue-600">
      <div className="w-full h-[40px] flex items-center text-[0.9rem] px-[5px] font-normal">
        Complete Payment -
        <span className="text-[#B5E4FC] ml-[5px]">â‚¹ {amount}</span>
      </div>
      <form onSubmit={handleSubmit} className="w-full flex flex-col">
        <PaymentElement options={{ layout: "accordion" }} />
        <div className="w-full flex space-x-3 mt-[5px] px-[2px]">
          <button
            type="submit"
            disabled={isLoading || !stripe || !elements}
            className="cursor-pointer h-[40px] flex items-center justify-center flex-1 bg-[#B5E4FC] hover:bg-[#E0F2FE] py-2 px-4 rounded disabled:opacity-50"
          >
            {isLoading ? (
              <>
                <Oval
                  visible={true}
                  color="#101828"
                  secondaryColor="#47494A"
                  strokeWidth="5"
                  ariaLabel="oval-loading"
                  wrapperClass="w-[15px] mr-[10px] flex items-center justify-center border-red-500"
                />
                <p className="text-[#101828] text-[0.8rem]">Processing...</p>
              </>
            ) : (
              <p className="text-[#101828] text-[0.8rem]">Pay Now</p>
            )}
          </button>
          <button
            type="button"
            onClick={onCancel}
            className="cursor-pointer h-[40px] flex items-center justify-center flex-1 bg-[#47494A] text-white text-[0.8rem]  py-2 px-4 rounded hover:bg-[#7D7D7D]"
          >
            Cancel
          </button>
        </div>
        {message && <div className="text-red-500 text-sm">{message}</div>}
      </form>
    </div>
  );
};


const BASE_URL: string =
  process.env.NEXT_PUBLIC_VERCEL_URL || "https://tripin-next.vercel.app";

export async function paymentInitiate(amount: number) {
  try {
    const response = await fetch(
      `${BASE_URL}/api/stripe/create-payment-intents`,
      {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ amount }),
      }
    );
    const data = await response.json();
    return data;
  } catch (error) {
    console.log(error);
  }
}



import { NextResponse } from "next/server";
import { stripe } from "@/lib/stripe";

export async function POST(request: Request) {
  try {
    const { amount } = await request.json();

    const paymentIntent = await stripe.paymentIntents.create({
      amount: amount * 100,
      currency: "inr",
      automatic_payment_methods: {
        enabled: true,
      },
    });

    return NextResponse.json({
      clientSecret: paymentIntent.client_secret,
    });
  } catch (err) {
    return NextResponse.json(
      { error: (err as Error).message },
      { status: 500 }
    );
  }
}




So my nextjs app project directory has two folders
frontend -> nextjs app
backend -> nodejs + express + prisma 

The project i am making is nextjs 15 Eccommerce website
now there are two entities in my app, admin and customer


below are the admin routes,
/admin/inventory/products/
/admin/inventory/categories/
/admin/inventory/attributes/..

admin routes are not accessible to customer.

for customer storefront, routes are
/shop/products
/shop/products/details
/shop/checkout
/shop/cart..



Now we dont necessarily make the customer signin to our app. He can checkout products etc..
But only when he tries to add to cart, tries to buy or checkout then we take him to
sign page.


for admin we necessarily want that only signed user who has admin role can visit the admin routes.
admin can visit the customer as well as admin routes, but customer cant visit the admin routes.


for sign up we have fullname,email,password both for admin and customer.
for sign in we have email and password.

Now i have setup the signup and sigin as of now and it works fine.
Backend has jwt token and other info in server setup cookies etc..

Now we want to have somethings still to be figured out like,

1. how to maintain the user session in frontend,
2. if admin or user wants to explicitly signout,
3. get the useSession info in client component and server components.


but most importantly we want to make the flow such that we have smooth and consistent redirections.

for example, when the app mounts, we need to check if the session has expire or not.

let say the session has expire then we have two cases,
1. if the session expired for was admin
2. if the session expired was customer

for admin we want to take them to /admin/auth/sign-in

for customer we wont take them to /shop/auth/sign-in we
just update the ui and now the header will no longer show the users name etc.
so the customer is just casually surfing the app just that he wont have any session.
but if the customer tries to again go to buy or add to cart then we take him to sign-in.


also if signed as customer then
he cant visit /admin routes and /shop/auth/sign-in and shop/auth/sign-up.

also if signed as admin then
he cant got to /admin/aith/sign-in /admin/auth/sign-up
he can go to shop/routes but also can go to /shop/auth routes.



so we need to figure out the route protection and session management.


NOTE: i am not using the nextjs api routes.
all the api goes to node js backend. Also i am not calling the fetch api in nexjt components.
i have separate service files which has function which call the fetch api.



Below is my current code file.
//PS  - since the admin and customer shares the same ui and input fields for signin and signup 
we have common components just different frontend routes,
/admin/auth/sign-in
/admin/auth/sign-up
/shop/auth/sign-in
/shop/auth/sign-up


// admin/auth/sign-in and sign-up files

"use client";
import AuthForm from "@/components/Common/Auth/AuthForm";
import { useRouter } from "next/navigation";

export default function AdminSignInPage() {
  const router = useRouter();
  return (
    <div className="w-full h-full flex items-center justify-center p-[0px] md:p-[30px] border">
      <div className="w-[100%] md:w-[70%] grid grid-cols-[100%] grid-rows-[40vh_70vh] md:grid-cols-[50%_50%] md:grid-rows-[100%] h-[100%] border border-black/10 p-[5px] overflow-y-scroll hide-scrollbar">
        <section className="w-full h-full flex items-center justify-center">
          <div className="w-[80%] h-[80%] flex flex-col">
            <p className="text-[2rem] font-medium">
              Admin Sign In,
              <br />
              for seamless management.
            </p>
            <p className="text-[0.9rem] font-medium mt-[10px] leading-loose">
              Welcome back! Manage products and orders with ease.
              <span className="text-[#907AEA] ml-[5px]">Unlock control.</span>
            </p>
          </div>
        </section>
        <section className="w-full h-full flex items-center justify-center p-[5px]">
          <AuthForm
            isSignUp={false}
            role="admin"
            basePath="/admin/auth"
            onSuccess={() => router.push("/admin/dashboard")}
          />
        </section>
      </div>
    </div>
  );
}



"use client";
import AuthForm from "@/components/Common/Auth/AuthForm";
import { useRouter } from "next/navigation";

export default function AdminSignUpPage() {
  const router = useRouter();

  return (
    <div className="w-full h-full flex items-center justify-center p-[0px] md:p-[30px]">
      <div className="w-[100%] md:w-[70%] grid grid-cols-[100%] grid-rows-[40vh_70vh] md:grid-cols-[50%_50%] md:grid-rows-[100%] h-[100%] border border-black/10 p-[5px] overflow-y-scroll hide-scrollbar">
        <section className="w-full h-full flex items-center justify-center">
          <div className="w-[80%] h-[80%] flex flex-col">
            <p className="text-[2rem] font-medium">
              Admin Sign Up,
              <br />
              for seamless management.
            </p>
            <p className="text-[0.9rem] font-medium mt-[10px] leading-loose">
              Join as an admin to manage products and orders effortlessly.
              <span className="text-[#907AEA] ml-[5px]">
                Start controlling now.
              </span>
            </p>
          </div>
        </section>
        <section className="w-full h-full flex items-center justify-center p-[5px]">
          <AuthForm
            isSignUp={true}
            role="admin"
            basePath="/admin/auth"
            onSuccess={() => router.push("/admin/auth/sign-in")}
          />
        </section>
      </div>
    </div>
  );
}



// shop/auth/sign-in and sign-up files


"use client";
import AuthForm from "@/components/Common/Auth/AuthForm";
import { useRouter } from "next/navigation";

export default function SignInPage() {
  const router = useRouter();

  return (
    <div className="w-full h-full flex items-center justify-center p-[0px] md:p-[30px]">
      <div className="w-[100%] md:w-[70%] grid grid-cols-[100%] grid-rows-[40vh_70vh] md:grid-cols-[50%_50%] md:grid-rows-[100%] h-[100%] border border-black/10 p-[5px] overflow-y-scroll hide-scrollbar">
        <section className="w-full h-full flex items-center justify-center">
          <div className="w-[80%] h-[80%] flex flex-col">
            <p className="text-[2rem] font-medium">
              Sign In,
              <br />
              for seamless experience.
            </p>
            <p className="text-[0.9rem] font-medium mt-[10px] leading-loose">
              Welcome back! Dive straight into your favorite finds and breeze
              through checkout.
              <span className="text-[#907AEA] ml-[5px]">
                Unlock, excitement.
              </span>
            </p>
          </div>
        </section>
        <section className="w-full h-full flex items-center justify-center p-[5px]">
          <AuthForm
            isSignUp={false}
            role="customer"
            basePath="/shop/auth"
            onSuccess={() => router.push("/shop")}
          />
        </section>
      </div>
    </div>
  );
}



"use client";
import AuthForm from "@/components/Common/Auth/AuthForm";
import { useRouter } from "next/navigation";

export default function SignUpPage() {
  const router = useRouter();

  return (
    <div className="w-full h-full flex items-center justify-center p-[0px] md:p-[30px]">
      <div className="w-[100%] md:w-[70%] grid grid-cols-[100%] grid-rows-[40vh_70vh] md:grid-cols-[50%_50%] md:grid-rows-[100%] h-[100%] border border-black/10 p-[5px] overflow-y-scroll hide-scrollbar">
        <section className="w-full h-full flex items-center justify-center">
          <div className="w-[80%] h-[80%] flex flex-col">
            <p className="text-[2rem] font-medium">
              Simple Finds,
              <br />
              Seamless Checkout.
            </p>
            <p className="text-[0.9rem] font-medium mt-[10px] leading-loose">
              Effortless shopping from discovery to checkoutâ€”browse handpicked
              finds and complete your purchase in seconds.
              <span className="text-[#907AEA] ml-[5px]">
                No Wait, Just Wow.
              </span>
            </p>
          </div>
        </section>
        <section className="w-full h-full flex items-center justify-center p-[5px]">
          <AuthForm
            isSignUp={true}
            role="customer"
            basePath="/shop/auth"
            onSuccess={() => router.push("/shop/auth/sign-in")}
          />
        </section>
      </div>
    </div>
  );
}




// common AuthForm


"use client";
import Link from "next/link";
import { FieldErrors, useForm } from "react-hook-form";
import { z } from "zod";
import { zodResolver } from "@hookform/resolvers/zod";
import { signIn, signUp } from "@/lib/services/auth/authServices";

// Zod schemas
const signInSchema = z.object({
  email: z.string().email("Invalid email format"),
  password: z
    .string()
    .min(6, "Password must be at least 6 characters")
    .regex(
      /^(?=.*[A-Z])(?=.*[0-9]).+$/,
      "Must contain at least 1 uppercase letter and 1 number"
    ),
});

const signUpSchema = signInSchema.extend({
  fullname: z
    .string()
    .min(2, "Name must be at least 2 characters")
    .regex(/^[a-zA-Z\s]+$/, "No numbers or special characters allowed"),
});

type SignInFormData = z.infer<typeof signInSchema>;
type SignUpFormData = z.infer<typeof signUpSchema>;

type AuthFormProps = {
  isSignUp: boolean;
  role: "customer" | "admin";
  basePath: string; // e.g., "/shop/auth" or "/admin/auth"
  onSuccess: () => void;
};

const AuthForm = ({ isSignUp, role, basePath, onSuccess }: AuthFormProps) => {
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
    setError,
  } = useForm<SignInFormData | SignUpFormData>({
    resolver: zodResolver(isSignUp ? signUpSchema : signInSchema),
  });

  const onSubmit = async (data: SignInFormData | SignUpFormData) => {
    try {
      if (isSignUp) {
        await signUp({ ...data, role } as SignUpFormData & {
          role: "customer" | "admin";
        });
      } else {
        await signIn({ ...data, role } as SignInFormData & {
          role: "customer" | "admin";
        });
      }
      onSuccess();
    } catch (error) {
      if (error instanceof Error) {
        setError("root", { message: error.message || "Authentication failed" });
      }
    }
  };

  const hasFullnameError = (
    errors: FieldErrors<SignInFormData | SignUpFormData>
  ): errors is FieldErrors<SignUpFormData> => {
    return !!errors && "fullname" in errors;
  };
  return (
    <form
      onSubmit={handleSubmit(onSubmit)}
      className="w-[95%] h-[90%] md:w-[80%] md:h-[80%] grid grid-rows-[15%_20%_20%_20%_25%] border border-black/10 rounded px-[25px] py-[10px]"
    >
      <div className="w-full h-full flex items-center justify-center">
        <p className="text-green-600 text-[0.7rem] bg-green-200 px-[10px] py-[5px] border rounded">
          {isSignUp
            ? "Welcome! Create your account"
            : "Successfully signed up. Sign in now"}
        </p>
      </div>

      {errors.root && (
        <div className="w-full h-full flex items-center justify-center">
          <p className="text-red-500 text-[0.7rem]">{errors.root.message}</p>
        </div>
      )}

      {/* FULLNAME GROUP (Sign-up only) */}
      {isSignUp && (
        <div className="w-[100%] h-[100%] grid grid-rows-[30px_minmax(0,1fr)_30px]">
          <div className="w-full h-[100%] flex items-center">
            <p className="text-[0.8rem] font-medium">FULLNAME</p>
          </div>
          <div className="w-full h-[100%]">
            <input
              {...register("fullname")}
              className="w-full h-full border-b border-black/20 text-[0.8rem]"
              placeholder="Enter your full name"
            />
          </div>
          <div className="w-full h-[100%]">
            {hasFullnameError(errors) && (
              <p className="text-red-500 text-[0.7rem]">
                {errors.fullname && errors.fullname.message}
              </p>
            )}
          </div>
        </div>
      )}

      {/* EMAIL GROUP */}
      <div className="w-[100%] h-[100%] grid grid-rows-[30px_minmax(0,1fr)_30px]">
        <div className="w-full h-[100%] flex items-center">
          <p className="text-[0.8rem] font-medium">EMAIL</p>
        </div>
        <div className="w-full h-[100%]">
          <input
            {...register("email")}
            className="w-full h-full border-b border-black/20 text-[0.8rem]"
            placeholder="Enter your email"
          />
        </div>
        <div className="w-full h-[100%]">
          {errors.email && (
            <p className="text-red-500 text-[0.7rem]">{errors.email.message}</p>
          )}
        </div>
      </div>

      {/* PASSWORD GROUP */}
      <div className="w-[100%] h-[100%] grid grid-rows-[30px_minmax(0,1fr)_30px]">
        <div className="w-full h-[100%] flex items-center">
          <p className="text-[0.8rem] font-medium">PASSWORD</p>
        </div>
        <div className="w-full h-[100%]">
          <input
            type="password"
            {...register("password")}
            className="w-full h-full border-b border-black/20 text-[0.8rem]"
            placeholder={isSignUp ? "Create a password" : "Enter your password"}
          />
        </div>
        <div className="w-full h-[100%]">
          {errors.password && (
            <p className="text-red-500 text-[0.7rem]">
              {errors.password.message}
            </p>
          )}
        </div>
      </div>

      {/* Footer - Submit Button */}
      <div className="w-[100%] h-[100%] flex flex-col items-center">
        <div className="w-full h-[50%]">
          <button
            type="submit"
            className="w-full h-[80%] bg-[#444444]"
            disabled={isSubmitting}
          >
            <p className="text-[0.7rem] text-white">
              {isSubmitting
                ? isSignUp
                  ? "Signing Up..."
                  : "Signing In..."
                : isSignUp
                ? "Sign Up"
                : "Sign In"}
            </p>
          </button>
        </div>
        <div className="w-full h-[50%] flex items-center justify-center">
          <p className="text-[0.7rem]">
            {isSignUp ? "Already have an account?" : "Not yet Signed Up?"}
            <Link
              className="font-medium hover:underline ml-1"
              href={`${basePath}/${isSignUp ? "sign-in" : "sign-up"}`}
            >
              {isSignUp ? "Sign In" : "Sign Up"}
            </Link>
          </p>
        </div>
      </div>
    </form>
  );
};

export default AuthForm;



// authServices.ts service file function 

const BASE_URL: string = process.env.NEXT_PUBLIC_API_BASE_URL || "";

interface SignUpPayload {
  fullname: string;
  email: string;
  password: string;
  role: "customer" | "admin";
}

interface SignInPayload {
  email: string;
  password: string;
  role: "customer" | "admin";
}

interface ApiResponse<T> {
  status: number;
  data: T | null;
  error: string | null;
  message?: string | null;
}

export async function signUp(
  payload: SignUpPayload
): Promise<
  ApiResponse<{ id: string; fullName: string; email: string; role: string }>
> {
  try {
    const response = await fetch(`${BASE_URL}/api/auth/sign-up`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload),
    });

    const result = await response.json();

    if (!response.ok) {
      console.error("Sign-up Error:", result.error || result.message);
      throw new Error(result.error || result.message || "Failed to sign up");
    }

    console.log("Sign-up Success:", result.message);
    return result;
  } catch (error) {
    const err = error as Error;
    console.error("Sign-up Error:", error);
    throw new Error(`Failed to sign up: ${err.message}`);
  }
}

export async function signIn(
  payload: SignInPayload
): Promise<
  ApiResponse<{ id: string; fullName: string; email: string; role: string }>
> {
  try {
    const response = await fetch(`${BASE_URL}/api/auth/sign-in`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload),
    });

    const result = await response.json();

    if (!response.ok) {
      console.error("Sign-in Error:", result.error || result.message);
      throw new Error(result.error || result.message || "Failed to sign in");
    }

    console.log("Sign-in Success:", result.message);
    return result;
  } catch (error) {
    const err = error as Error;
    console.error("Sign-in Error:", error);
    throw new Error(`Failed to sign in: ${err.message}`);
  }
}

export async function signOut(): Promise<void> {
  try {
    const response = await fetch(`${BASE_URL}/api/auth/sign-out`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
    });

    if (!response.ok) {
      const result = await response.json();
      console.error("Sign-out Error:", result.error || result.message);
      throw new Error(result.error || result.message || "Failed to sign out");
    }

    console.log("Sign-out Success");
  } catch (error) {
    const err = error as Error;
    console.error("Sign-out Error:", error);
    throw new Error(`Failed to sign out: ${err.message}`);
  }
}




// nodejs routes and controller,

import { Router } from "express";
import { authController } from "../../controllers/auth/auth.controller";
const router = Router();

router.post("/sign-in", authController.signInController);
router.post("/sign-up", authController.signUpController);

export default router;




//controller
import { RequestHandler } from "express";
import { createResponse } from "../../utils/apiResponseUtils";
import prisma from "../../db/prisma";
import bcrypt from "bcrypt";
import { z } from "zod";
import jwt from "jsonwebtoken";

const signUpSchema = z.object({
  fullname: z
    .string()
    .min(2)
    .regex(/^[a-zA-Z\s]+$/, "No numbers or special characters"),
  email: z.string().email(),
  password: z
    .string()
    .min(6)
    .regex(/^(?=.*[A-Z])(?=.*[0-9]).+$/),
  role: z.enum(["customer", "admin"]),
});

const signInSchema = z.object({
  email: z.string().email(),
  password: z.string().min(6),
  role: z.enum(["customer", "admin"]),
});

const createJwtToken = (payload: {
  userId: string;
  email: string;
  role: string;
}) => {
  return jwt.sign(payload, process.env.JWT_SECRET!, { expiresIn: "14d" });
};

const signUpController: RequestHandler = async (req, res) => {
  try {
    // Validate input
    const parsed = signUpSchema.safeParse(req.body);
    if (!parsed.success) {
      return createResponse(
        res,
        400,
        null,
        "Invalid input: " + parsed.error.message
      );
    }

    const { fullname, email, password, role } = parsed.data;

    // Check if email exists
    const existingUser = await prisma.user.findUnique({ where: { email } });
    if (existingUser) {
      return createResponse(res, 400, null, "Email already exists");
    }

    // Hash password
    const hashedPassword = await bcrypt.hash(password, 10);

    // Create user
    const user = await prisma.user.create({
      data: {
        fullname,
        email,
        password: hashedPassword,
        role,
      },
    });

    // Generate JWT
    const token = createJwtToken({
      userId: user.id,
      email: user.email,
      role: user.role,
    });

    // Set cookie
    res.cookie("auth_token", token, {
      httpOnly: true,
      secure: process.env.NODE_ENV === "production",
      sameSite: "strict",
      maxAge: 14 * 24 * 60 * 60 * 1000, // 2 weeks
    });

    return createResponse(
      res,
      201,
      { id: user.id, fullname, email, role },
      null,
      "Sign-up successful"
    );
  } catch (error: any) {
    return createResponse(
      res,
      500,
      null,
      error.message || "Internal server error"
    );
  }
};

const AuthMessages = {
  USER_NOT_FOUND: "No account found with this email",
  INVALID_PASSWORD: "Incorrect password",
  AUTH_ERROR: "Authentication failed. Please try again later.",
};

// Sign-in controller
const signInController: RequestHandler = async (req, res) => {
  try {
    // Validate input
    const parsed = signInSchema.safeParse(req.body);
    if (!parsed.success) {
      return createResponse(
        res,
        400,
        null,
        "Invalid input: " + parsed.error.message
      );
    }

    const { email, password, role } = parsed.data;

    // Find user
    const user = await prisma.user.findUnique({ where: { email } });
    if (!user) {
      return createResponse(res, 401, null, AuthMessages.USER_NOT_FOUND);
    }

    const isPasswordValid = await bcrypt.compare(password, user.password);

    if (!isPasswordValid) {
      return createResponse(res, 401, null, AuthMessages.INVALID_PASSWORD);
    }

    // Validate role
    if (user.role !== role) {
      return createResponse(res, 403, null, "Invalid role for this user");
    }

    // Generate JWT
    const token = createJwtToken({
      userId: user.id,
      email: user.email,
      role: user.role,
    });

    // Set cookie
    res.cookie("auth_token", token, {
      httpOnly: true,
      secure: process.env.NODE_ENV === "production",
      sameSite: "strict",
      maxAge: 14 * 24 * 60 * 60 * 1000, // 2 weeks
    });

    return createResponse(
      res,
      200,
      { id: user.id, fullName: user.fullname, email, role },
      null,
      "Sign-in successful"
    );
  } catch (error: any) {
    return createResponse(
      res,
      500,
      null,
      error.message || "Internal server error"
    );
  }
};

interface DecodedToken {
  userId: string;
  email: string;
  role: "admin" | "customer";
  iat: number;
  exp: number;
}

interface SessionResponse {
  user: {
    id: string;
    fullname: string;
    email: string;
    role: "admin" | "customer";
  } | null;
}

export const validateSessionController: RequestHandler = async (req, res) => {
  try {
    // 1. Get token from cookies
    const token = req.cookies.auth_token;

    // 2. If no token, return unauthenticated
    if (!token) {
      return createResponse(res, 200, null, null, "No session token found");
    }

    // 3. Verify JWT token
    const decoded = jwt.verify(token, process.env.JWT_SECRET!) as DecodedToken;

    // 4. Check token expiration
    const now = Math.floor(Date.now() / 1000);
    if (decoded.exp < now) {
      res.clearCookie("auth_token");
      return createResponse(res, 200, null, null, "Session expired");
    }

    // 5. Fetch user from database
    const user = await prisma.user.findUnique({
      where: { id: decoded.userId },
      select: {
        id: true,
        fullname: true,
        email: true,
        role: true,
      },
    });

    // 6. If user not found, clear cookie
    if (!user) {
      res.clearCookie("auth_token");
      return createResponse(res, 200, null, null, "User not found");
    }

    // 7. Return valid user data
    const sessionResponse: SessionResponse = {
      user: {
        id: user.id,
        fullname: user.fullname,
        email: user.email,
        role: user.role as "admin" | "customer",
      },
    };

    return createResponse(res, 200, sessionResponse, null, "Session valid");
  } catch (error) {
    // Handle JWT verification errors
    if (error instanceof jwt.JsonWebTokenError) {
      res.clearCookie("auth_token");
      return createResponse(res, 200, null, null, "Invalid session token");
    }

    // Handle other errors
    console.error("Session validation error:", error);
    return createResponse(res, 500, null, "Internal server error", null);
  }
};
export const authController = {
  signUpController,
  signInController,
  validateSessionController,
};



//index.ts
import express, { Application, Request, Response, NextFunction } from "express";
import dotenv from "dotenv";
import cors from "cors";
import cookieParser from "cookie-parser";
import router from "./routes";
dotenv.config();

const app: Application = express();
const PORT: number = parseInt(process.env.PORT as string, 10) || 9000;
// app.use(cors());
app.use(
  cors({
    origin: "http://localhost:3000", // Allow only your frontend origin
    credentials: true, // Allow cookies and credentials
    methods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
    allowedHeaders: ["Content-Type", "Authorization"],
  })
);

app.use(express.json());
app.use(cookieParser());
// Error Handling Middleware
app.use((err: Error, req: Request, res: Response, next: NextFunction) => {
  console.error(err.message);
  res.status(500).json({ error: err.message });
});

app.use("/api", router);

app.listen(PORT, () => {
  console.log(`Server running on: http://localhost:${PORT}`);
});













shop routes,
/shop/.. -> products, product details page..
/shop/auth/sign-in
/shop/auth/sign-up
/shop/user/[userId]/cart
/shop/user/[userId]/checkout


admin routes,
/admin/auth/sign-in
/admin/auth/sign-up
/admin/inventory/products



for customer(user),


1. If signed-in 

can visit, (all shop routes)
  -> /shop/user/[userId]/cart
  -> /shop/user/[userId]/checkout
  -> /shop..

cant visit,
 -> /shop/auth/sign-in
 -> /shop/auth/sign-up


2. If not signed in,

can visit,
 -> /shop/auth/sign-in
 -> /shop/auth/sign-up


cant visit,
  -> /shop/user/[userId]/cart
  -> /shop/user/[userId]/checkout


3. Can never visit /admin... routes



for admin,

1. If signed-in 

can visit,
-> /admin/inventory/...

cant visit,
-> /admin/auth/sign-in
-> /admin/auth/sign-up

2. If not signed-in

can visit,
-> /admin/auth/sign-in
-> /admin/auth/sign-up

cant visit,
-> /admin/inventory/...

3. Admin can visit behave like customer












- mlmlmlmm






problem,
only admin can got /admin... routes
but not if we are signed in as customer and tries to go to /admin/inventory/...
then we are restricted but we can go to /admin/auth/sign-in and sign-up which is not intended.




Lets make is simple.

first check for authentication.


if authenticated,

-> if role = admin
    - can go to all paths except /admin/auth/* and /shop/auth*


-> if role=customer

    - can go to
      /shop/user/[userId]/cart
      /shop/user/[userId]/checkout

    - cant go to /admin/* 


if not authenticated,

-> can go to /shop/auth/*
-> can go to /admin/auth/*
-> can go to /shop other route like products etc.


-> cant go to /admin/inventory/*
-> cant go to/shop/user/[userId]/cart
-> cant go to /shop/user/[userId]/checkout
    



so if we are authenticated, then we need to route based on the role.
if not authenticated then its straight forward.










import { NextResponse } from "next/server";
import type { NextRequest } from "next/server";
import { createServerClient } from "./lib/auth/session";

export async function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl;
  const response = NextResponse.next();

  // Skip static files and API routes
  if (pathname.startsWith("/_next") || pathname.startsWith("/api")) {
    return response;
  }

  const auth = await createServerClient();
  const { user } = await auth.getSession();

  // Set session data for client components
  if (user) {
    await auth.setSession({ user });
  } else {
    response.cookies.delete("session_data");
  }

  // 1. First handle admin routes
  if (pathname.startsWith("/admin")) {
    // 1a. Always allow access to admin auth pages
    if (pathname.startsWith("/admin/auth")) {
      // If already signed in as admin, redirect to dashboard
      if (user?.role === "admin") {
        return NextResponse.redirect(
          new URL("/admin/inventory/products", request.url)
        );
      }
      // Allow access to sign-in/sign-up for others
      return response;
    }

    // 1b. Block customers from ALL admin routes
    if (user?.role === "customer") {
      return NextResponse.redirect(new URL("/shop", request.url));
    }

    // 1c. Require admin role for other admin routes
    if (!user || user.role !== "admin") {
      const url = new URL("/admin/auth/sign-in", request.url);
      url.searchParams.set("redirect", pathname);
      return NextResponse.redirect(url);
    }

    return response;
  }

  // 2. Handle shop routes
  if (pathname.startsWith("/shop")) {
    // 2a. Redirect signed-in users away from auth pages
    if (pathname.startsWith("/shop/auth") && user) {
      return NextResponse.redirect(new URL("/shop", request.url));
    }

    // 2b. Protect user-specific routes
    if (pathname.startsWith("/shop/user")) {
      if (!user) {
        const url = new URL("/shop/auth/sign-in", request.url);
        url.searchParams.set("redirect", pathname);
        return NextResponse.redirect(url);
      }

      // Verify user ID matches
      const userIdFromPath = pathname.split("/")[3];
      if (userIdFromPath && user.id && userIdFromPath !== user.id) {
        const correctPath = pathname.replace(userIdFromPath, user.id);
        return NextResponse.redirect(new URL(correctPath, request.url));
      }
    }

    return response;
  }

  // 3. Handle root path
  if (pathname === "/") {
    if (user?.role === "admin") {
      return NextResponse.redirect(
        new URL("/admin/inventory/products", request.url)
      );
    }
    return NextResponse.redirect(new URL("/shop", request.url));
  }

  return response;
}

export const config = {
  matcher: ["/((?!_next/static|_next/image|favicon.ico).*)"],
};
